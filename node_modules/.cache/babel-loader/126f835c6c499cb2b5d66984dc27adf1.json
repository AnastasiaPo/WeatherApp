{"ast":null,"code":"/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n} // https://github.com/lukeed/uid/blob/master/src/index.js\n\n/* eslint no-bitwise: 'off' */\n\n/* eslint no-plusplus: 'off' */\n\n/* eslint @typescript-eslint/strict-boolean-expressions: 'off' */\n\n\nvar IDX = 36;\nvar HEX = '';\n\nwhile (IDX--) {\n  HEX += IDX.toString(36);\n}\n\nfunction uid(len) {\n  if (len === void 0) {\n    len = 11;\n  }\n\n  var str = '';\n  var num = len;\n\n  while (num--) {\n    str += HEX[Math.random() * 36 | 0];\n  }\n\n  return str;\n} // We need escape certain characters before creating the RegExp\n// https://github.com/sindresorhus/escape-string-regexp\n\n\nvar escapeRegexp = function (term) {\n  return term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, function (char) {\n    return \"\\\\\" + char;\n  });\n};\n\nvar regexpQuery = function (_a) {\n  var terms = _a.terms,\n      _b = _a.matchExactly,\n      matchExactly = _b === void 0 ? false : _b;\n\n  if (typeof terms !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  var escapedTerms = escapeRegexp(terms.trim());\n  return \"(\" + (matchExactly ? escapedTerms : escapedTerms.split(' ').join('|')) + \")\";\n};\n\nvar hasProp = function (prop) {\n  return function (obj) {\n    return obj !== null && typeof obj !== 'undefined' && prop in obj;\n  };\n};\n\nvar hasMatch = hasProp('match');\n/**\r\n * This provides context around a chunk's text, based on the next and previous chunks.\r\n * e.g. If we have the string \"The quick brown fox jumped over the lazy dog\",\r\n * and the search term \"fox jumped\", with a padding of 2, we want to have the end result be:\r\n * \"... quick brown fox jumped over the ...\"\r\n * The search term, \"fox jumped\" is left as is, and the left and right chunks, instead of having\r\n * the text in full, will be clipped.\r\n */\n\nfunction clip(_a) {\n  var curr = _a.curr,\n      next = _a.next,\n      prev = _a.prev,\n      _b = _a.clipBy,\n      clipBy = _b === void 0 ? 3 : _b;\n  var words = curr.text.split(' ');\n  var len = words.length; // If the current is a match, we leave it alone\n  // Or if the clipBy is greater than or equal to the length of the words, there's nothing to clip\n\n  if (curr.match || clipBy >= len) {\n    return curr.text;\n  } // If we have a clipBy greater than the length of the words in the current match,\n  // it means we can clip the words in the current chunk\n\n\n  var ellipsis = '...';\n\n  if (hasMatch(prev) && hasMatch(next)) {\n    // Both the previous and the next chunks are a match\n    // Let's check if we have enough words to clip by on both sides\n    if (len > clipBy * 2) {\n      return __spreadArrays(words.slice(0, clipBy), [ellipsis], words.slice(-clipBy)).join(' ');\n    }\n\n    return curr.text;\n  } // We start to check the next and previous matches in order to\n  // properly position the elipsis\n\n\n  if (hasMatch(next)) {\n    // The chunk right after this one is a match\n    // So we need the elipsis at the start of the returned text\n    // so that it sticks correctly to the next (match)'s text\n    return __spreadArrays([ellipsis], words.slice(-clipBy)).join(' ');\n  }\n\n  if (hasMatch(prev)) {\n    // The chunk right before this one is a match\n    // So we need the elipsis at the end of the                                 returned text\n    // so that it sticks correctly to the previous (match)'s text\n    return __spreadArrays(words.slice(0, clipBy), [ellipsis]).join(' ');\n  } // If we made it this far, just return the text\n\n\n  return curr.text;\n}\n\nvar hasLength = function (str) {\n  return str.length > 0;\n};\n/**\r\n * Split a text into chunks denoting which are a match and which are not based on a user search term.\r\n * @param text          String  The text to split.\r\n * @param query         String  The query to split by. This can contain multiple words.\r\n * @param clipBy        Number  Clip the non-matches by a certain number of words to provide context around the matches.\r\n * @param matchExactly  Boolean If we have multiple words in the query, we will match any of the words if exact is false. For example, searching for \"brown fox\" in \"the brown cute fox\" will yield both \"brown\" and \"fox\" as matches. While if exact is true, the same search will return no results.\r\n */\n\n\nvar highlightWords = function (_a) {\n  var text = _a.text,\n      query = _a.query,\n      clipBy = _a.clipBy,\n      _b = _a.matchExactly,\n      matchExactly = _b === void 0 ? false : _b; // Let's make sure that the user cannot pass in just a bunch of spaces\n\n  var safeQuery = query.trim();\n\n  if (safeQuery === '') {\n    return [{\n      key: uid(),\n      text: text,\n      match: false\n    }];\n  }\n\n  var searchRegexp = new RegExp(regexpQuery({\n    terms: safeQuery,\n    matchExactly: matchExactly\n  }), 'ig');\n  return text.split(searchRegexp) // Split the entire thing into an array of matches and non-matches\n  .filter(hasLength) // Filter any matches that have the text with length of 0\n  .map(function (str) {\n    return {\n      // Compose the object for a match\n      key: uid(),\n      text: str,\n      match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)\n    };\n  }).map(function (chunk, index, chunks) {\n    return __assign(__assign({}, chunk), typeof clipBy === 'number' && {\n      // We only overwrite the text if there is a clip\n      text: clip(__assign(__assign(__assign({\n        curr: chunk\n      }, index < chunks.length - 1 && {\n        next: chunks[index + 1]\n      }), index > 0 && {\n        prev: chunks[index - 1]\n      }), {\n        // If this wasn't the first chunk, set the previous chunk\n        clipBy: clipBy\n      }))\n    });\n  });\n};\n\nexport default highlightWords;","map":{"version":3,"sources":["/Users/a.ponkrashenkova/Documents/GitHub/WeatherApp/node_modules/highlight-words/dist/lib-esm/index.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArrays","il","r","Array","k","a","j","jl","IDX","HEX","toString","uid","len","str","num","Math","random","escapeRegexp","term","replace","char","regexpQuery","_a","terms","_b","matchExactly","TypeError","escapedTerms","trim","split","join","hasProp","prop","obj","hasMatch","clip","curr","next","prev","clipBy","words","text","match","ellipsis","slice","hasLength","highlightWords","query","safeQuery","key","searchRegexp","RegExp","filter","map","toLowerCase","test","chunk","index","chunks"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\n\n// https://github.com/lukeed/uid/blob/master/src/index.js\r\n/* eslint no-bitwise: 'off' */\r\n/* eslint no-plusplus: 'off' */\r\n/* eslint @typescript-eslint/strict-boolean-expressions: 'off' */\r\nvar IDX = 36;\r\nvar HEX = '';\r\nwhile (IDX--) {\r\n    HEX += IDX.toString(36);\r\n}\r\nfunction uid(len) {\r\n    if (len === void 0) { len = 11; }\r\n    var str = '';\r\n    var num = len;\r\n    while (num--) {\r\n        str += HEX[(Math.random() * 36) | 0];\r\n    }\r\n    return str;\r\n}\n\n// We need escape certain characters before creating the RegExp\r\n// https://github.com/sindresorhus/escape-string-regexp\r\nvar escapeRegexp = function (term) {\r\n    return term.replace(/[|\\\\{}()[\\]^$+*?.-]/g, function (char) { return \"\\\\\" + char; });\r\n};\r\nvar regexpQuery = function (_a) {\r\n    var terms = _a.terms, _b = _a.matchExactly, matchExactly = _b === void 0 ? false : _b;\r\n    if (typeof terms !== 'string') {\r\n        throw new TypeError('Expected a string');\r\n    }\r\n    var escapedTerms = escapeRegexp(terms.trim());\r\n    return \"(\" + (matchExactly ? escapedTerms : escapedTerms.split(' ').join('|')) + \")\";\r\n};\n\nvar hasProp = function (prop) { return function (obj) {\r\n    return obj !== null && typeof obj !== 'undefined' && prop in obj;\r\n}; };\r\nvar hasMatch = hasProp('match');\r\n/**\r\n * This provides context around a chunk's text, based on the next and previous chunks.\r\n * e.g. If we have the string \"The quick brown fox jumped over the lazy dog\",\r\n * and the search term \"fox jumped\", with a padding of 2, we want to have the end result be:\r\n * \"... quick brown fox jumped over the ...\"\r\n * The search term, \"fox jumped\" is left as is, and the left and right chunks, instead of having\r\n * the text in full, will be clipped.\r\n */\r\nfunction clip(_a) {\r\n    var curr = _a.curr, next = _a.next, prev = _a.prev, _b = _a.clipBy, clipBy = _b === void 0 ? 3 : _b;\r\n    var words = curr.text.split(' ');\r\n    var len = words.length;\r\n    // If the current is a match, we leave it alone\r\n    // Or if the clipBy is greater than or equal to the length of the words, there's nothing to clip\r\n    if (curr.match || clipBy >= len) {\r\n        return curr.text;\r\n    }\r\n    // If we have a clipBy greater than the length of the words in the current match,\r\n    // it means we can clip the words in the current chunk\r\n    var ellipsis = '...';\r\n    if (hasMatch(prev) && hasMatch(next)) {\r\n        // Both the previous and the next chunks are a match\r\n        // Let's check if we have enough words to clip by on both sides\r\n        if (len > clipBy * 2) {\r\n            return __spreadArrays(words.slice(0, clipBy), [\r\n                ellipsis\r\n            ], words.slice(-clipBy)).join(' ');\r\n        }\r\n        return curr.text;\r\n    }\r\n    // We start to check the next and previous matches in order to\r\n    // properly position the elipsis\r\n    if (hasMatch(next)) {\r\n        // The chunk right after this one is a match\r\n        // So we need the elipsis at the start of the returned text\r\n        // so that it sticks correctly to the next (match)'s text\r\n        return __spreadArrays([ellipsis], words.slice(-clipBy)).join(' ');\r\n    }\r\n    if (hasMatch(prev)) {\r\n        // The chunk right before this one is a match\r\n        // So we need the elipsis at the end of the                                 returned text\r\n        // so that it sticks correctly to the previous (match)'s text\r\n        return __spreadArrays(words.slice(0, clipBy), [ellipsis]).join(' ');\r\n    }\r\n    // If we made it this far, just return the text\r\n    return curr.text;\r\n}\n\nvar hasLength = function (str) { return str.length > 0; };\r\n/**\r\n * Split a text into chunks denoting which are a match and which are not based on a user search term.\r\n * @param text          String  The text to split.\r\n * @param query         String  The query to split by. This can contain multiple words.\r\n * @param clipBy        Number  Clip the non-matches by a certain number of words to provide context around the matches.\r\n * @param matchExactly  Boolean If we have multiple words in the query, we will match any of the words if exact is false. For example, searching for \"brown fox\" in \"the brown cute fox\" will yield both \"brown\" and \"fox\" as matches. While if exact is true, the same search will return no results.\r\n */\r\nvar highlightWords = function (_a) {\r\n    var text = _a.text, query = _a.query, clipBy = _a.clipBy, _b = _a.matchExactly, matchExactly = _b === void 0 ? false : _b;\r\n    // Let's make sure that the user cannot pass in just a bunch of spaces\r\n    var safeQuery = query.trim();\r\n    if (safeQuery === '') {\r\n        return [\r\n            {\r\n                key: uid(),\r\n                text: text,\r\n                match: false\r\n            }\r\n        ];\r\n    }\r\n    var searchRegexp = new RegExp(regexpQuery({ terms: safeQuery, matchExactly: matchExactly }), 'ig');\r\n    return text\r\n        .split(searchRegexp) // Split the entire thing into an array of matches and non-matches\r\n        .filter(hasLength) // Filter any matches that have the text with length of 0\r\n        .map(function (str) { return ({\r\n        // Compose the object for a match\r\n        key: uid(),\r\n        text: str,\r\n        match: matchExactly\r\n            ? str.toLowerCase() === safeQuery.toLowerCase()\r\n            : searchRegexp.test(str)\r\n    }); })\r\n        .map(function (chunk, index, chunks) { return (__assign(__assign({}, chunk), (typeof clipBy === 'number' && {\r\n        // We only overwrite the text if there is a clip\r\n        text: clip(__assign(__assign(__assign({ curr: chunk }, (index < chunks.length - 1 && { next: chunks[index + 1] })), (index > 0 && { prev: chunks[index - 1] })), { // If this wasn't the first chunk, set the previous chunk\r\n            clipBy: clipBy }))\r\n    }))); });\r\n};\n\nexport default highlightWords;\n"]},"metadata":{},"sourceType":"module"}